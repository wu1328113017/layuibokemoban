<!DOCTYPE html>
<html>
<head>
<style>body{padding:1.875rem;}</style><meta charset='UTF-8'>
</head>
<body><p><b>背景：</b></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 随着业务越来越多，功能越来越复杂，就需要在原来的类的基础上进行修改，这违背了开放-封闭原则，所以要增加功能都会选择继承这个类来扩展功能，但这样做的话业务功能简单还好，要是多的话就会写很多子类，就比如扩展4个功能，但要不桶的组合，就有15个组合，也就是要写15个类来扩展，所以在慢慢的磨合下就创造了-装饰器模式</p><p><b>介绍：</b></p><p><b>&nbsp; &nbsp; &nbsp; &nbsp; </b>装饰器的意思就是装饰形体的物件，就比如在电脑上的壁纸，鼠标垫上的图案和各种花里胡哨的对于电脑来说就是装饰器，说的再简单点就是人身上的衣物，戒指对于人来说就是装饰器，而Java中装饰器模式的要点就在于把功能相当于装饰物一样装饰在类上，也就是给类穿上了衣物，戴上了戒指</p><p><b>装饰器具体模块划分</b></p><p><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="https://wdz-1258450135.cos.ap-shanghai.myqcloud.com/bk/3c9f388ed2b44416909a415af9b6fb18.png" alt="图片暂时显示不出"></b></p><p><b><br></b></p><p><b>Componet(组件）：</b>组件接口定义了全部组件实现类以及所有装饰器实现的行为</p><p><b>ConcreteComponent(具体组件实现类):</b>具体组件实现类实现了Component接口。通常情况下，具体组件实现类就是被装饰器装饰的原始对象，该类提供了Component接口中定义的最基本的功能，其他高级功能或后续添加的新功能，都是通过装饰器的方式添加到该类的对象之上的。</p><p><b>Decorator(装饰器）：</b>所有装饰器的父类，它是一个实现了Component接口的抽象类，并在其中封装了一个Component对象，也就是被装饰的对象。而这个被装饰的对象只要是Component类型即可，这就是吸纳了装饰器的组合和复用。</p><p><b>ConcreteDecorator:</b>具体的装饰器实现类，该实现类要向被装饰对象添加某些功能。</p><p><b>代码示例</b></p><p><b>Component接口类：</b></p><pre><p><span>//定义一个人的基本行为</span></p><p><span>public interface </span>People {</p>    <span>void </span>show();<br>}</pre><p><b>ConcreteComponent类：</b></p><pre><p><span>//组件的具体实现类</span></p><p><span>public class </span>Person <span>implements </span>People{</p>    <span>public void </span>show() {<br>        System.<span>out</span>.println(<span>"这是一个裸体的人"</span>);<br>    }
}</pre><p><b>Decorator抽象类：</b></p><pre><p><span>//定义装饰器抽象父类</span></p><p><span>public abstract class </span>AbstractPeople <span>implements </span>People{</p><br>    <span>private </span>People <span>people</span>;<br>    <span>public </span>AbstractPeople(People people){<br>        <span>this</span>.<span>people </span>= people;<br>    }<br><br>    <span>public void </span>show() {<br>        <span>people</span>.show();<br>    }<br>}</pre><p><b>ConcreteDecorator类：</b></p><pre><p><span>//装饰器：继承装饰器抽象父类，实现给人装饰一件上衣的功能</span></p><p><span>public class </span>JacketPeople <span>extends </span>AbstractPeople {</p>    <span>public </span>JacketPeople(People abstractPeople){<br>        <span>super</span>(abstractPeople);<br>    }<br><br>    <span>@Override<br></span><span>    </span><span>public void </span>show() {<br>        <span>super</span>.show();<br>        say();<br>    }<br><br>    <span>public void </span>say(){<br>        System.<span>out</span>.println(<span>"这是一个已经穿了上衣的人类"</span>);<br>    }
}</pre><pre><p><span>//</span>装饰器：继承装饰器抽象父类，实现给人装饰一件裤子的功能</p><p><span>public class </span>TrousersPeople <span>extends </span>AbstractPeople {</p>    <span>public </span>TrousersPeople(People abstractPeople){<br>        <span>super</span>(abstractPeople);<br>    }<br><br>    <span>@Override<br></span><span>    </span><span>public void </span>show() {<br>        <span>super</span>.show();<br>        say();<br>    }<br>    <span>public void </span>say(){<br>        System.<span>out</span>.println(<span>"这是一个已经穿了裤子的人类"</span>);<br>    }
}</pre><p><b>测试类：</b></p><pre><span>public class </span>Test {<br>    <span>public static void </span>main(String[] args) {<br>        <span>new </span>TrousersPeople(<span>new </span>JacketPeople(<span>new </span>Person())).show();<br>    }<br>}</pre><p><b>输出：</b></p><p>这是一个裸体的人</p><p>这是一个已经穿了上衣的人类</p><p></p><p>这是一个已经穿了裤子的人类</p><p><b>具体细节分析：</b></p><p>这里的类都可以说是People接口的实现类，也就是People的类型，所以在装饰器抽象父类定义了一个构造器，这个构造器就限制了子类的构造器传入的参数必须为People类型，也就是必须传装饰器或具体实现类，也就是人的裸体，对于这串代码<span>new </span><span>TrousersPeople(</span><span>new </span><span>JacketPeople(</span><span>new </span><span>Person())).show();最外面是装饰器，最里面new Person()是创造了一个裸体的人类，也就是被装饰对象，外层就是被装饰物一层一层的装饰着，而</span>new&nbsp;TrousersPeople(new&nbsp;JacketPeople())是把new&nbsp;JacketPeople()添加上衣的功能和添加裤子的功能结合了起来</p><p><b>总结:</b></p><p>跟着代码走一遍就会发现这样做就很灵活，我可以随时再加一双鞋子，只需要创建这个鞋子的装饰器类就行了，然后搭配不同的组合，可以跟上衣一起穿，可以跟裤子一起穿，也可以上衣，裤子，鞋子一起穿，只需要new TrousersPeople(new JacketPeople())就把上衣和裤子两个装饰器可组合在一起了，如果再加上鞋子，只需要在new JacketPeople()构造器里面传入鞋子装饰器的实例就行了，如果不要上衣，就把new JacketPeople()这个上衣的实例给去除，删掉这段代码就行了，如果我们不使用装饰器模式，就直接使用继承去继承人类的裸体这个具体实现类，然后添加上衣就要写一个子类，添加裤子又要写一个，同时添加上衣和裤子又要写一个，如果还有鞋子呢？又有几种不同的组合方式，鞋子-上衣-裤子，鞋子-裤子，鞋子-上衣，又要写几个子类，所以就会有很多类，浪费存储空间，增加程序负担</p><p><b>应用例子</b></p><p>在jdk中的io类库就使用了大量的装饰器类，还要mybatis的缓存模块也使用了装饰器模式</p><p><b>优点</b></p><p>相较于于继承来说，装饰器模式的灵活性更强，可扩展型也强。</p><p>当有新功能需要添加时，只需要添加新的装饰器实现类，然后通过组合方式添加这个新装饰器即可，无需修改已有的代码，符合”开放-封闭“的原则</p><p><b>缺点</b></p><p>随着添加的功能越来越多，可能会创建出嵌套多层装饰器的对象，这增加了系统的复杂性，也增加了理解的难度和定位错误的难度</p></body>
</html>
