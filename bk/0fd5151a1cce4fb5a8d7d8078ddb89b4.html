<!DOCTYPE html>
<html>
<head>
<style>body{padding:1.875rem;}</style><meta charset='UTF-8'>
</head>
<body><p>参考：<a target="_blank" href="https://blog.csdn.net/caidingnu/article/details/91345042">https://blog.csdn.net/caidingnu/article/details/91345042</a></p><p>socket服务端代码：</p><pre><span>import </span>java.io.*;<br><span>import </span>java.net.ServerSocket;<br><span>import </span>java.net.Socket;<br><br><span>public class </span>MyServerSocket {<br>    <span>public static void </span>main(String[] args) <span>throws </span>IOException {<br>        ServerSocket ss = <span>new </span>ServerSocket(<span>8089</span>);<br>        Socket s = ss.accept();<span>//阻塞，就是运行到这段代码如果检测到没有连接程序就会停留在这里不往下执行</span><span>    </span><br>        DataOutputStream out = <span>new </span>DataOutputStream(s.getOutputStream());      <span><br></span><span>        //发送文件<br></span><span>        </span>File f = <span>new </span>File(<span>"E:</span><span>\\</span><span>面试资料</span><span>\\</span><span>面试题</span><span>\\</span><span>ActiveMQ消息中间件面试专题.pdf"</span>);//传文件所在的地址<br>        out.writeUTF(f.getName());//文件名<br>        out.flush();<br>        InputStream in = <span>new </span>FileInputStream(f);<span><br></span><span>        </span><span>byte</span>[] bs = <span>new byte</span>[<span>1024</span>];//设置1024个byte，也就是1024个字节<span><br></span><p><span>        </span>in.read(bs);<br><p>        int length = 0;</p>        ①while((length = in.read(bs, 0, bs.length)) != -1) {
            out.write(bs, 0, length);
            out.flush();
        }</p>        out.close();//关闭他们，释放资源<br>        in.close();<br>        s.close();<br>        ss.close();<br>    }<br>}</pre><p>socket客户端代码：</p><pre><span>import </span>java.io.*;<br><span>import </span>java.net.Socket;<br><br><span>public class </span>MyClientSocket {<br>    <span>public static void </span>main(String[] args) <span>throws </span>IOException {<br>        Socket s = <span>new </span>Socket(<span>"localhost"</span>,<span>8089</span>);<br>        InputStream inFromServer = s.getInputStream();<br>        DataInputStream in = <span>new </span>DataInputStream(inFromServer);<br>        String filename = in.readUTF();<br>        <span>byte</span>[] bs = <span>new byte</span>[<span>1024</span>];<span><br></span><span>        </span>File dec = <span>new </span>File(<span>"G:</span><span>\\</span><span>test</span><span>\\</span><span>socket练习文件存放目录"</span>);//传入文件存放地址<br>        <span>if</span>(!dec.exists()){//如果文件夹不存在则创建<br>            dec.mkdir();<br>        }<br>        File file = <span>new </span>File(dec.getAbsolutePath() + ②File.<span>separatorChar </span>+ filename);<br>        OutputStream os = <span>new </span>FileOutputStream(file);<br>        <span>int </span>length = <span>0</span>;<br>       ① <span>while</span>((length = in.read(bs, <span>0</span>, bs.<span>length</span>)) != -<span>1</span>) {<br>            os.write(bs, <span>0</span>, length);<br>            os.flush();<br>        }
<span>        os.close()；<br></span><span>        </span>inFromServer.close();<br>        in.close();<br>        s.close();<br>    }<br>}</pre><p>与代码对应的标号的解释</p><p>①：这个我也是看了半天才懂，这个代码执行的逻辑是：</p><p>1.截取输入流in中0-1024（bs字节数组的长度）的字节到bs字节数组中。</p><p>2然后将read方法的返回值赋值给length，read方法的作用是判断输入流中是否还有字节，如果等于-1，说明没有字节了，不等于-1的话那它的返回值是截取的0-1024个字节中能截取的长度（意思是假如输入流中还剩400个字节，然后我要截取0-1024个字节，这个时候因为还有字节所以read方法不会返回-1，它返回的是400，也就是输入流中还有的字节数）。</p><p>3.执行os.write方法是将bs数组中0-length个字节写入到输出流os中。</p><p>4.执行os.flush是将数据强制发送到目的地，这里就是输出到输出流os中。</p><p>5.然后再循环到开始地方再来一次，每循环一次，输入流in中的字节都会减少length个，直到输入流in中没有字节为止。</p><p>总结：这样做的好处是不受数组长度的限制可以把数据完整的传输过去</p><p>反面例子：</p><p>byte[] bs = new byte[1024];</p><p>in.read(bs);</p><p>out.write(bs);</p><p>out.flush();</p><p>这样传输会导致数据不完整，因为字节数受bs的长度限制，假如我输入流的字节数大于1024，传过去的数据就少了，如果小于1024，假如为1000，那多出来的24个字节会默认赋值为0，所以数据就错误了。</p><p>也可以直接将File类的length方法返回值（既是字节数量）声明为bs的长度，但因为bs的长度必须声明为int类型，而File类的length方法返回值为long类型，当然可以强转成int类型，但万一文件过大呢？大到int类型装不下就会报错</p><p>length方法</p><p>②：<span>表明文件路径区分符，比如在中英文下就是"\"，日文下"￥"，Unix下"/"，用File.separatorChar会根据系统自动代替这些字符，比直接用有更好的通用性。</span></p></body>
</html>
